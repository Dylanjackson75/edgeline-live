import pandas as pd, numpy as np
from sklearn.linear_model import Ridge

def fit_player_impact(players_games: pd.DataFrame) -> pd.DataFrame:
    # Build design matrix: each row = stint/game; columns = players (on court = 1; off = 0)
    # For simplicity, use game-level plus/minus per 100 poss as target
    df = players_games.copy()
    df["net100"] = (df["team_pts"] - df["opp_pts"]) * (100.0 / df["poss"].clip(lower=1))
    # Create wide player presence matrix (starter or played > 0 mins)
    played = df[df["minutes"] > 0]
    mat = played.pivot_table(index=["date","team","opponent"], columns="player",
                             values="minutes", aggfunc="sum").fillna(0.0)
    pres = (mat > 0).astype(float)
    y = df.groupby(["date","team","opponent"], as_index=False)["net100"].mean().set_index(["date","team","opponent"])["net100"].reindex(pres.index)
    X = pres.values
    model = Ridge(alpha=10.0, fit_intercept=True).fit(X, y.values)
    coefs = pd.Series(model.coef_, index=pres.columns, name="impact_net_per100")
    return coefs.reset_index().rename(columns={"index":"player"})

def forecast_minutes(players_games: pd.DataFrame, injuries: pd.DataFrame, date: str, team: str) -> pd.DataFrame:
    recent = players_games[(players_games["team"]==team)].sort_values("date").groupby("player").tail(10)
    base = recent.groupby("player")["minutes"].mean().rename("exp_min").reset_index()
    # Injury adjustment
    out = set(injuries[(injuries["date"]<=date)&(injuries["status"].str.lower()=="out")]["player"].tolist())
    base.loc[base["player"].isin(out), "exp_min"] = 0.0
    # Rebalance to team total cap (NBA 240)
    total = base["exp_min"].sum()
    cap = 240.0
    if total > 0:
        base["exp_min"] = base["exp_min"] * (cap/total)
    base["team"] = team
    return base

def project_game(players_games, injuries, date, home, away, player_impacts):
    mh = forecast_minutes(players_games, injuries, date, home)
    ma = forecast_minutes(players_games, injuries, date, away)
    imp = player_impacts.set_index("player")["impact_net_per100"]
    home_net = (mh.set_index("player")["exp_min"].mul(imp.reindex(mh["player"]).fillna(0)).sum())/240.0
    away_net = (ma.set_index("player")["exp_min"].mul(imp.reindex(ma["player"]).fillna(0)).sum())/240.0
    fair_spread_home = - (home_net - away_net)  # sportsbook convention
    # Pace/total (very simple baseline; replace with learned model)
    base_total = 225.0  # NBA baseline; learn per league
    fair_total = base_total + 0.4*(home_net + away_net)
    return fair_spread_home, fair_total
# bb_engine.py
import pandas as pd, numpy as np
from pathlib import Path
from sklearn.linear_model import Ridge

# ---------- Data loaders (graceful fallbacks) ----------
def _try_read(path):
    p = Path(path)
    if p.exists():
        return pd.read_csv(p)
    return pd.DataFrame()

def load_players_games(path="data/basketball/players_games.csv"):
    return _try_read(path)

def load_injuries(path="data/basketball/injuries.csv"):
    return _try_read(path)

# ---------- Modeling ----------
def fit_player_impact(players_games: pd.DataFrame) -> pd.DataFrame:
    if players_games.empty:
        return pd.DataFrame({"player":[],"impact_net_per100":[]})
    df = players_games.copy()
    # possession estimate if missing
    if "poss" not in df.columns:
        df["poss"] = (df.get("pace", 98)*40/48).fillna(90)
    df["net100"] = (df["team_pts"] - df["opp_pts"]) * (100.0 / df["poss"].clip(lower=1))
    played = df[df["minutes"] > 0]
    if played.empty:
        return pd.DataFrame({"player":[],"impact_net_per100":[]})
    mat = played.pivot_table(index=["date","team","opponent"], columns="player",
                             values="minutes", aggfunc="sum").fillna(0.0)
    pres = (mat > 0).astype(float)
    y = df.groupby(["date","team","opponent"], as_index=False)["net100"].mean().set_index(
        ["date","team","opponent"]
    )["net100"].reindex(pres.index).fillna(0.0)
    model = Ridge(alpha=10.0, fit_intercept=True).fit(pres.values, y.values)
    coefs = pd.Series(model.coef_, index=pres.columns, name="impact_net_per100")
    return coefs.reset_index().rename(columns={"index":"player"})

def forecast_minutes(players_games: pd.DataFrame, injuries: pd.DataFrame, date: str, team: str, cap_minutes: float) -> pd.DataFrame:
    if players_games.empty:
        return pd.DataFrame(columns=["player","exp_min","team"])
    recent = players_games[(players_games["team"]==team)].sort_values("date").groupby("player").tail(10)
    if recent.empty:
        return pd.DataFrame(columns=["player","exp_min","team"])
    base = recent.groupby("player")["minutes"].mean().rename("exp_min").reset_index()
    # injuries: status outâ†’0
    if not injuries.empty:
        out = set(injuries[(injuries["date"]<=date)&(injuries["status"].str.lower()=="out")]["player"].tolist())
        base.loc[base["player"].isin(out), "exp_min"] = 0.0
    # Rebalance to cap
    total = base["exp_min"].sum()
    if total > 0:
        base["exp_min"] = base["exp_min"] * (cap_minutes/total)
    base["team"] = team
    return base

def project_game(date:str, home:str, away:str, level:str="NBA") -> tuple[float,float]:
    """
    Returns: fair_spread_home (book convention), fair_total
    level: "NBA" or "NCAAB"
    Fallback: neutral numbers if no data present.
    """
    players = load_players_games()
    injuries = load_injuries()
    cap = 240.0 if level=="NBA" else 200.0
    if players.empty:
        # Fallback neutral projection
        base_total = 227.0 if level=="NBA" else 142.0
        return 0.0, base_total

    imp = fit_player_impact(players)
    if imp.empty:
        base_total = 227.0 if level=="NBA" else 142.0
        return 0.0, base_total

    mh = forecast_minutes(players, injuries, date, home, cap)
    ma = forecast_minutes(players, injuries, date, away, cap)
    if mh.empty or ma.empty:
        base_total = 227.0 if level=="NBA" else 142.0
        return 0.0, base_total

    imp_s = imp.set_index("player")["impact_net_per100"]
    home_net = (mh.set_index("player")["exp_min"].mul(imp_s.reindex(mh["player"]).fillna(0)).sum())/cap
    away_net = (ma.set_index("player")["exp_min"].mul(imp_s.reindex(ma["player"]).fillna(0)).sum())/cap

    fair_spread_home = - (home_net - away_net)  # sportsbook convention
    base_total = 227.0 if level=="NBA" else 142.0
    fair_total = base_total + 0.4*(home_net + away_net)
    return float(fair_spread_home), float(fair_total)

