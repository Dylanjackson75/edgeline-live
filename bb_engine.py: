# bb_engine.py
import pandas as pd, numpy as np
from pathlib import Path
from sklearn.linear_model import Ridge

def _try_read(path):
    p = Path(path)
    return pd.read_csv(p) if p.exists() else pd.DataFrame()

def load_players_games(path="data/basketball/players_games.csv"):
    return _try_read(path)

def load_injuries(path="data/basketball/injuries.csv"):
    return _try_read(path)

def fit_player_impact(players_games: pd.DataFrame) -> pd.DataFrame:
    """Estimate player impact using ridge regression on net ratings per 100 possessions."""
    if players_games.empty:
        return pd.DataFrame({"player":[],"impact_net_per100":[]})
    df = players_games.copy()
    if "poss" not in df.columns:
        df["poss"] = (df.get("pace", 98)*40/48).fillna(90)
    df["net100"] = (df["team_pts"] - df["opp_pts"]) * (100.0 / df["poss"].clip(lower=1))
    played = df[df["minutes"] > 0]
    if played.empty:
        return pd.DataFrame({"player":[],"impact_net_per100":[]})
    mat = played.pivot_table(index=["date","team","opponent"], columns="player",
                             values="minutes", aggfunc="sum").fillna(0.0)
    pres = (mat > 0).astype(float)
    y = df.groupby(["date","team","opponent"], as_index=False)["net100"].mean().set_index(
        ["date","team","opponent"]
    )["net100"].reindex(pres.index).fillna(0.0)
    model = Ridge(alpha=10.0, fit_intercept=True).fit(pres.values, y.values)
    coefs = pd.Series(model.coef_, index=pres.columns, name="impact_net_per100")
    return coefs.reset_index().rename(columns={"index":"player"})

def forecast_minutes(players_games: pd.DataFrame, injuries: pd.DataFrame, date: str, team: str, cap_minutes: float) -> pd.DataFrame:
    """Forecast expected minutes given recent play and injuries."""
    if players_games.empty:
        return pd.DataFrame(columns=["player","exp_min","team"])
    recent = players_games[(players_games["team"]==team)].sort_values("date").groupby("player").tail(10)
    if recent.empty:
        return pd.DataFrame(columns=["player","exp_min","team"])
    base = recent.groupby("player")["minutes"].mean().rename("exp_min").reset_index()
    if not injuries.empty:
        out = set(injuries[(injuries["date"]<=date)&(injuries["status"].str.lower()=="out")]["player"].tolist())
        base.loc[base["player"].isin(out), "exp_min"] = 0.0
    total = base["exp_min"].sum()
    if total > 0:
        base["exp_min"] = base["exp_min"] * (cap_minutes/total)
    base["team"] = team
    return base

def project_game(date:str, home:str, away:str, level:str="NBA") -> tuple[float,float]:
    """Return (fair_spread_home, fair_total) based on player impact."""
    players = load_players_games()
    injuries = load_injuries()
    cap = 240.0 if level=="NBA" else 200.0
    if players.empty:
        base_total = 227.0 if level=="NBA" else 142.0
        return 0.0, base_total

    imp = fit_player_impact(players)
    if imp.empty:
        base_total = 227.0 if level=="NBA" else 142.0
        return 0.0, base_total

    mh = forecast_minutes(players, injuries, date, home, cap)
    ma = forecast_minutes(players, injuries, date, away, cap)
    if mh.empty or ma.empty:
        base_total = 227.0 if level=="NBA" else 142.0
        return 0.0, base_total

    imp_s = imp.set_index("player")["impact_net_per100"]
    home_net = (mh.set_index("player")["exp_min"].mul(imp_s.reindex(mh["player"]).fillna(0)).sum())/cap
    away_net = (ma.set_index("player")["exp_min"].mul(imp_s.reindex(ma["player"]).fillna(0)).sum())/cap

    fair_spread_home = - (home_net - away_net)  # sportsbook convention
    base_total = 227.0 if level=="NBA" else 142.0
    fair_total = base_total + 0.4*(home_net + away_net)
    return float(fair_spread_home), float(fair_total)
